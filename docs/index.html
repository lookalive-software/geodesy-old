<html>
    <head>
        <meta charset="UTF-8">
        <!-- blank favicon to supress extra request-->
        <link rel="icon" type="image/x-icon" href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABmJLR0T///////8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAAF0lEQVRIx2NgGAWjYBSMglEwCkbBSAcACBAAAeaR9cIAAAAASUVORK5CYII=">
        <script src="js/elementary.js"></script>
        <script src="js/kvetch.js"></script>
        <script src="js/htmlprops.js"></script>
        <script src="js/formbinder.js"></script>
    
        <!-- <script src="js/geodesyform.js" defer="true"></script> -->
        <!-- <script src="js/outTurf.js" defer="true"></script> -->

        <script src="templates/geodesyForm.js"></script>
        <script src="templates/geodesyFormStyle.js"></script>
        <script src="templates/motifStyle.js"></script>
        <script src="templates/normData.js"></script>
    </head>
    <body>
        <script>
            document.body.innerElement = elementary(geodesyFormStyle())


            window.cache = {}
            Promise.all([
                kvetch.get(`cache/square.json`).then(res => window.cache.square = res),
                kvetch.get(`cache/pyritohedron.json`).then(res => window.cache.pyritohedron = res),
                kvetch.get(`cache/honeycomb.json`).then(res => window.cache.honeycomb = res),
                kvetch.get(`cache/p4octagon.json`).then(res => window.cache.p4octagon = res)
            ]).then(()=>{
                let newGeodesy = registerGeodesy('pyritohedron')

                setTimeout(()=>resizeGeodesy(newGeodesy), 10)

                

                // add the form to the page
                // click the start button that creates a styletag and a geodesy form

                // the stylesheet rules are prefixed to only apply to one...

                // geodesyCreate() // maybe once motif is changed?
                // geodesyResize(geodesy) // maybe once motif is changed?    
            })

            

            function registerGeodesy(motifName){
                let UUID = 'x' + Math.round(Math.random() * Math.pow(2,24)).toString(16)
                // take default values
                console.log("UUID", UUID)
                // document.body.innerElement = elementary(motifStyle(window.cache[motifName].motif))
                document.body.appendChild(createElementary(
                    {"geodesy":{
                        "id": UUID,
                        "motif": motifName,
                        "size": "20"
                    }}
                ))
                
                let uniqueGeodesy = document.getElementById(UUID)
                document.body.innerElement = elementary(geodesyForm(UUID))
                formbinder()

                uniqueGeodesy.onAttributeChanged = function({attribute, oldValue, newValue}){
                    console.log({attribute, newValue})
                    // console.log({"this":this})
                    switch(attribute){
                        case 'xoffset':
                        case 'yoffset':
                        case 'zoom':
                            // 
                            // this.querySelector('style').sheet.rule
                            this.style.transform = `scale(${this.props.zoom || 1}) translateX(${this.props.xoffset || 0}vw) translateY(Calc(-1 * (${this.props.yoffset || 0}vh))`
                            break
                        case 'size':
                            resizeGeodesy(this)
                            break;
                    }
                }

                // setTimeout(()=>{
                    uniqueGeodesy.appendChild(createElementary(
                        motifStyle(UUID, window.cache[motifName].motif)
                    ))
                // }, 100)

                return uniqueGeodesy
            }

            function destroyGeodesy(element){
                    // then delete child.
                    // could set some attribute to hide it / apply animation, delete it 50 ms later... 
                    Array.from(element.querySelectorAll('norm.visibility'), (norm, index) => {
                        setTimeout(()=>norm.classList.toggle('visibility'), 50 * index)
                    })
                    // destroy tag...
                    // destroy form associated with it too...
                    document.querySelector(`form[target="${element.props.id}"]`).remove()
            }

            function resizeGeodesy(element){
                let visible = element.querySelectorAll('norm.visibility')
                if(visible.length < element.props.size){ // implicit conversion from string to number for comparison
                // current number of children is the index into the next position. If I have 2 children, they are index 0 and 1, so the next child is index 2.

                // call elementary with this polygondata [name, number, polygondData[]]
                // map over the polygonData to interpolate the spin values into markup
                // attach the norm and spin markup to the geodesy element. 
                    let normIndex = visible.length
                    let availableNorms = element.querySelectorAll('norm')
                    // if norm hasn't been deleted yet, cancel its timeout and keep using it...
                    if(availableNorms[normIndex]){
                        availableNorms[normIndex].classList.toggle('visibility') 
                        // cancel removal...
                        clearTimeout(parseInt(availableNorms[normIndex].props.timeout))
                    } else {
                        // otherwise fetch data and create new set of norms
                        let nextNorm = window.cache[element.props.motif].norms[normIndex]
                        element.appendChild(createElementary(normData(normIndex, nextNorm)))

                    }

                    // after a timeout, I can toggle 
                    // 
                    setTimeout(function(){
                        element.lastChild.classList.toggle('visibility') 
                        resizeGeodesy(element) 
                    }, 50)
                }
                if(visible.length > element.props.size ){
                    // then delete child.
                    // could set some attribute to hide it / apply animation, delete it 50 ms later... 
                    
                    let markedForDeletion = visible[visible.length - 1]
                    markedForDeletion.classList.toggle('visibility') 
                    markedForDeletion.props.timeout = setTimeout(function(){
                        markedForDeletion.remove()
                    }, 10000)
                    setTimeout(()=>resizeGeodesy(element), 50)
                }
            }

            // for the attribute change listeners on each geodesy element...
            // registergeodesy will take a newly created geodesy element, and attach attributechanged callbacks
            // some of those callbacks are going to need the style tag controlling the geodesy tag.
            // so create the style tag, create the geodesy, set a reference to styleTag on geodesy...
            // so geodesy can read its own styletag.

        </script>
    </body>
</html>

