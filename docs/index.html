<html>
    <head>
        <meta charset="UTF-8">
        <!-- blank favicon to supress extra request-->
        <link rel="icon" type="image/x-icon" href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABmJLR0T///////8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAAF0lEQVRIx2NgGAWjYBSMglEwCkbBSAcACBAAAeaR9cIAAAAASUVORK5CYII=">
        <script src="js/elementary.js"></script>
        <script src="js/kvetch.js"></script>
        <script src="js/propmodified.js"></script>
        <!-- <script src="js/formbinder.js"></script> -->
        <script src="js/controlpanel.js"></script>
        <!-- <script src="js/shiftspace.js"></script> -->
    
        <script src="js/geodesyUtil.js" defer="true"></script>
        <!-- <script src="js/outTurf.js" defer="true"></script> -->

        <script src="templates/formTemplate.js"></script> <!--a template to generate forms -->
        <script src="templates/formStyle.js"></script> <!--global stylesheet for all forms -->
        <script src="templates/motifStyle.js"></script> <!-- global stylesheet for all geodesy motifs-->
        <script src="templates/normTemplate.js"></script> <!-- generates polygons and targets-->
    </head>
    <body id="body">
        <!-- <geodesy
            id="honeycombA"
            shells="15"
            radius="100"
            bg-color="#000000"
            fg-color="#ffffff"
            backoff="1.05"
            fillmode="merge"
            draw="paint"
        ></geodesy> -->
        <style>
            body {
                overflow: hidden;
            }
            nav {
                height: 100%;
                position: absolute;
                right: 0;
                z-index: 1;
                overflow-x: hidden;
                overflow-y: auto;
            }
        </style>
        <nav id="editor">

        </nav>
        <script>
            // attach listener to geodesy, onclick, toggle active class of event.target.
            
            // document.body.innerElement = elementary(geodesyFormStyle())

            /*

            // the bitmask callback then goes over the children and sets them as active or not
            */

            window.cache = {}
            Promise.all([
                kvetch.get(`cache/square.json`).then(res => window.cache.square = res),
                kvetch.get(`cache/pyritohedron.json`).then(res => window.cache.pyritohedron = res),
                kvetch.get(`cache/honeycomb.json`).then(res => window.cache.honeycomb = res),
                kvetch.get(`cache/p4octagon.json`).then(res => window.cache.p4octagon = res)
            ]).then(()=>{ // create the form with all available options
                // when the form is submitted, it generates a random ID, 
                document.head.appendChild(createElementary([
                    motifStyle(), // uses window.cache and generates stylesheet, attaches to head
                    formStyle()
                ]))
                // document.body.getElementById('nav') // how about focusing a form sets the active element in the title, and jumps to position on screen
                editor.appendChild(controlpanel(formTemplate)) // no taret to start
                // want to make sure when created and destroyed, I use my bitmask and everything to apply old props to new pattern
                document.querySelector('form:not([target])').addEventListener('submit', event => {
                    event.preventDefault()
                    // this form element is getting its target reset before calling on, so once the element is created, the form knows where to look
                    // so geodesy propModified on the contorl panel has to check that geodesy id is current form.props.target
                    event.target.props.target = geodesy.getRandomID()
                    // event.target.querySelector('details').removeAttribute('open')
                    function propsFromForm(formElement){
                        return {

                            id: formElement.props.target
                        }
                    }

                    let newprops = {id: } 
                    // the target of 
                    // ID can be a hidden form value... basically 'this form is about to be applied to a new ',
                    Array.from(event.target.querySelectorAll('input, select, textarea'), inputElement => {
                        switch(inputElement.type){
                            case 'checkbox':
                                newprops[inputElement.name] = inputElement.checked
                                break
                            case 'radio':
                                newprops[inputElement.name] = inputElement.id
                                break
                            default:
                                newprops[inputElement.name] = inputElement.value
                        }
                    })
                    if(!newprops.title){
                        newprops.title = newprops.id
                    } else {
                        event.target.querySelector('input[name="title"]').value = ""
                    }
                    console.log(newprops)
                    // if title is blank set randomID as title
                    // if its changed, title is changed, but target + ID stay the random one

                    document.body.appendChild(createElementary({geodesy: newprops}))
                    editor.appendChild(controlpanel(formTemplate, geodesy.propModified, newprops.id))
                })

                // on submit.... create a control panel with geodesy.propModified listener
            })
                // Array.from(document.querySelectorAll('geodesy'), geodesyElement => {
                    // create form without a target, make sure default values exist

                    // what to do for each geodesy element already on the page
                    // ideally to save the state of the page, 
                    // just take the list of geodesy elements and get their props
                    // and that should create a file good enough to recreate the page with.

                    // add form to control it...
                    // geodesyCreate(geodesyElement) // create the style element first
                    // altspace(geodesyElement) // give click and drag control for paintbrush
                    // document.body.appendChild(geodesyControl(geodesyElement))
                    // geodesyElement.props.motif = "p4octagon"
                    // geodesyElement.addEventListener('click', event => {

                    //     // if signal came from a polygon, set 'active' on its target

                    //     // set active true or false based on whether draw mod is paint (or erase)
                    //     inputElement.firstChild.props.active = (geodesyElement.props.draw === 'paint')
                    // })
                    // just because motif is the prop that sets it all off
                    // it has to be called before any other attributes
                    // so I guess that means there has to be some external means to kick it off :/
                // })
            // })
            // for the attribute change listeners on each geodesy element...
            // registergeodesy will take a newly created geodesy element, and attach attributechanged callbacks
            // some of those callbacks are going to need the style tag controlling the geodesy tag.
            // so create the style tag, create the geodesy, set a reference to styleTag on geodesy...
            // so geodesy can read its own styletag.

        </script>
    </body>
</html>