<html>
    <head>
        <meta charset="UTF-8">
        <!-- blank favicon to supress extra request-->
        <link rel="icon" type="image/x-icon" href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABmJLR0T///////8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAAF0lEQVRIx2NgGAWjYBSMglEwCkbBSAcACBAAAeaR9cIAAAAASUVORK5CYII=">
        <script src="js/elementary.js"></script>
        <script src="js/kvetch.js"></script>
        <script src="js/propmodified.js"></script>
        <script src="js/formbinder.js"></script>
        <script src="js/controlpanel.js"></script>
    
        <!-- <script src="js/geodesyform.js" defer="true"></script> -->
        <!-- <script src="js/outTurf.js" defer="true"></script> -->

        <script src="templates/geodesyForm.js"></script>
        <script src="templates/geodesyFormStyle.js"></script>
        <script src="templates/motifStyle.js"></script>
        <script src="templates/normData.js"></script>
    </head>
    <body id="body">
        <script>
            document.body.innerElement = elementary(geodesyFormStyle())


            window.cache = {}
            Promise.all([
                kvetch.get(`cache/square.json`).then(res => window.cache.square = res),
                kvetch.get(`cache/pyritohedron.json`).then(res => window.cache.pyritohedron = res),
                kvetch.get(`cache/honeycomb.json`).then(res => window.cache.honeycomb = res),
                kvetch.get(`cache/p4octagon.json`).then(res => window.cache.p4octagon = res)
            ]).then(()=>{
                let newGeodesy = registerGeodesy('p4octagon')

                // add the form to the page
                // click the start button that creates a styletag and a geodesy form

                // the stylesheet rules are prefixed to only apply to one...

                // geodesyCreate() // maybe once motif is changed?
                // geodesyResize(geodesy) // maybe once motif is changed?    
            })

            

            function registerGeodesy(motifName){
                let UUID = 'x' + Math.round(Math.random() * Math.pow(2,24)).toString(16)
                // take default values
                console.log("UUID", UUID)
                // document.body.innerElement = elementary(motifStyle(window.cache[motifName].motif))
                document.body.appendChild(createElementary(
                    {"geodesy":{
                        "id": UUID,
                        "motif": motifName,
                        "radius":"100",
                        "cast-shadow":"true",
                        "norbit": "15",
                        "globalscale": "1",
                    }}
                ))
                
                let uniqueGeodesy = document.getElementById(UUID)
                uniqueGeodesy.appendChild(createElementary(
                    motifStyle(UUID, window.cache[motifName].motif)
                ))

                controlpanel(UUID, [
                    {"label":[
                        "tile size",
                        {"input":{"id":"globalscale","type":"range","min":"0.1","max":"1.01","step":"0.01"}}
                    ]},
                    {"label": [
                        "number of orbits", 
                        {"input":{
                            "id":"norbit","type":"range","min":"1","max":"50","step":"1"
                        }}
                    ]},
                    {"label": [
                        "cast shadow", 
                        {"input":{
                            "id":"cast-shadow","type":"checkbox","checked":"true"
                            // "id":"tilesize","type":"range","min":"0.1","max":"1.05","step":"0.05"
                        }}
                    ]}, 
                    {"label": [
                        "radius", 
                        {"input":{
                            "id":"radius","type":"number","min":"1","max":"200","step":"1"
                        }},
                        "px"
                    ]},
                    {"label": [
                        // "ax+b",
                        {"input": {"type":"number", "min":"0","max":"50","step":"1","placeholder":"a","id":"a" }},
                        "x + ",
                        {"input": {"type":"number", "min":"0","max":"50","step":"1","placeholder":"b", "id":"b"}},
                    ]},
                    {"label": [
                        "foreground/background",
                        {"input": {"type":"color","id":"fg-color" }},
                        {"input": {"type":"color", "id":"bg-color"}},
                    ]},
                    {"label": [
                        "choose lattice",
                        {"select id='motif'": [
                            {"option": {"value": "none", "childNodes": ["none"]}},
                            {"option": {"value": "square", "childNodes": ["square"]}},
                            {"option": {"value": "pyritohedron", "childNodes": ["pyritohedron"]}},
                            {"option": {"selected":"", "value": "p4octagon", "childNodes": ["p4octagon"]}},
                            {"option": {"value": "honeycomb", "childNodes": ["honeycomb"]}},
                        ]}
                    ]}
                ], function({propName, oldValue, newValue}){
                    switch(propName){
                        // maybe some photography settings
                        case 'globalscale':
                        case 'fg-color':
                        case 'bg-color':
                            this.setStyleVar(propName, newValue)
                            break
                        case 'radius':
                            this.setStyleVar(propName, newValue + 'px')
                            break
                        case 'norbit':
                            resizeGeodesy(this)
                            break
                        case 'a':
                        case 'b':
                            let sheet = this.querySelector('style').sheet
                            if(sheet.rules[0].selectorText.includes('norm:nth-child')){
                                // there can only by one
                                sheet.deleteRule(0)
                            }
                            sheet.insertRule(`norm:nth-child(${this.props.a || 1}n + ${this.props.b || 0}) target {background: var(--fg-color) !important}`)
                            break
                    }
                })
                // document.body.innerElement = elementary(geodesyForm(UUID))
                // formbinder()
                // need to step through form and trigger the same 'input changed' callback...

                resizeGeodesy(uniqueGeodesy)

                // uniqueGeodesy.onAttributeChanged = function({attribute, oldValue, newValue}){
                //     // console.log({attribute, newValue})
                //     // console.log({"this":this})
                //     switch(attribute){
                //         case 'motif':
                //             destroyGeodesy(this).then(()=>{
                //                 uniqueGeodesy.appendChild(createElementary(
                //                     motifStyle(UUID, window.cache[this.props.motif].motif)
                //                 ))
                //                 resizeGeodesy(this)
                //                 // maybe even call formbinder again, to update the other values...
                //             })
                //             break
                //         case 'xoffset':
                //         case 'yoffset':
                //         case 'zoom':
                //             // 
                //             // this.querySelector('style').sheet.rule
                //             this.style.transform = `scale(${this.props.zoom || 1}) translateX(${this.props.xoffset || 0}vw) translateY(Calc(-1 * (${this.props.yoffset || 0}vh))`
                //             break
                //         case 'size':
                //             resizeGeodesy(this)
                //             break;
                //         case 'i':
                //         case 'j':
                //             let sheet = this.querySelector('style').sheet
                //             if(sheet.rules[0].selectorText.includes('norm:nth-child')){
                //                 // there can only by one
                //                 sheet.deleteRule(0)
                //             }
                //             // maybe set --active color
                //             // so I can use either one at a time painting or norm painting...
                //             // maybe --active-image too...
                //             // basically check if there's already a 'norm:nth-child()' selector...
                //             sheet.insertRule(`norm:nth-child(${this.props.i || 1}n + ${this.props.j || 0}) target {background: black !important}`)
                //             break
                //     }
                // }

                return uniqueGeodesy
            }

            function destroyGeodesy(element){
                return new Promise(resolve => {
                    // then delete child.
                    let visible = element.querySelectorAll('norm.visibility')
                    // could set some attribute to hide it / apply animation, delete it 50 ms later... 
                    Array.from(visible, (norm, index) => {
                        setTimeout(()=>norm.classList.toggle('visibility'), 50 * index)
                    })

                    setTimeout(function(){
                        while(element.children.length){
                            element.lastChild.remove()
                        }
                        resolve()
                    }, visible.length * 50 + 250)
                    // destroy tag...
                    // when the form is removed, I'll want to call destroy and then set a timeout to actually destroy it
                    // document.querySelector(`form[target="${element.props.id}"]`).remove()
                })
            }

            function resizeGeodesy(element){
                let visible = element.querySelectorAll('norm.visibility')
                if(visible.length < element.props.norbit){ // implicit conversion from string to number for comparison
                // current number of children is the index into the next position. If I have 2 children, they are index 0 and 1, so the next child is index 2.

                // call elementary with this polygondata [name, number, polygondData[]]
                // map over the polygonData to interpolate the spin values into markup
                // attach the norm and spin markup to the geodesy element. 
                    let normIndex = visible.length
                    let availableNorms = element.querySelectorAll('norm')
                    // if norm hasn't been deleted yet, cancel its timeout and keep using it...
                    if(availableNorms[normIndex]){
                        availableNorms[normIndex].classList.toggle('visibility') 
                    } else {
                        // otherwise fetch data and create new set of norms
                        let nextNorm = window.cache[element.props.motif].norms[normIndex]
                        element.appendChild(createElementary(normData(normIndex, nextNorm)))
                        setTimeout(()=>element.lastChild.classList.toggle('visibility'), 5)
                        // console.log('neighbors', element.lastChild.props.neighbors)
                    }
                    
                    setTimeout(function(){ resizeGeodesy(element) }, 50)
                }
                if(visible.length > element.props.norbit ){
                    // then delete child.
                    // could set some attribute to hide it / apply animation, delete it 50 ms later... 
                    let markedForDeletion = visible[visible.length - 1]
                    markedForDeletion.classList.toggle('visibility') 
                    setTimeout(()=>resizeGeodesy(element), 50)
                }
            }

            // for the attribute change listeners on each geodesy element...
            // registergeodesy will take a newly created geodesy element, and attach attributechanged callbacks
            // some of those callbacks are going to need the style tag controlling the geodesy tag.
            // so create the style tag, create the geodesy, set a reference to styleTag on geodesy...
            // so geodesy can read its own styletag.

        </script>
    </body>
</html>

